

- char	*get_next_line(int fd)
- fd = file descriptor => descripteur de fichier
- un descripteur de fichier est un entier
- Tout entier >2 correspond generalement a des fichiers
- la fonction get_next_line(int fd) => va donc s'appliquer sur sur le fichier pointe par la fonction

- int fd = open("monfichier.txt", O_RDONLY);
- open() ouvre le fichier

- declarer une variable char *buffer pour stocker ce que lis read() 
- la taille de ce buffer peut varier voila pourquoi on l'appelle de la maniere suivante : char buffer[BUFFER_SIZE]
- pas oublier de mettre un static en plus pour que la variable garde sa valeur entre les appels de la fonction => static char buffer[BUFFER_SIZE]
- taille maximal du buffer (memoir tampon) et des 1024 bytes/octets soit 1 mega byte/octet (dans ce cas de figure)

- ssize_t read(int fd, void *buf, size_t count)
- cette fonction va lire dans le fichier (int fd) et va ensuite copier count(size_t count) * caractere dans le buffer(void *buf) et return le nbr d'octetts lus (peut etre inferieur a count)
- si une erreur se produit dans read => return (-1)
- void *buf => pointeur vers un tampon dans lequel les donnees seront stocke
- la fonction read va servir à remplir de buffer d'autant de caractere qu'il a d'espace voila pourquoi count sera egal a la taille du buffer
- première idée pour la fonction read => read(fd, buffer, BUFFER_SIZE)

Questions :
- Est ce qu'il y a besoin de mallocer la mémoire du tampon pour être sur de ne pas avoir de problème ?
- Si le tampon est remplis lors de la première itération comment sera t il possible de faire une nouvelle itération et de mettre des caractère dans le buffer deja pleins ?
- La question précédente par du principe que la taille du buffer peut etre variable c'est a dire que le code doit aussi bien fonctionné avec une taille de 1024 octets qu'avec une taille de un octet.
Y aurait-il donc besoin d'une autre variable plus grande dans laquelle stocker le résultat de chaque itération ?

buffer :
- Puisqu'il est déclaré comme statique, sa mémoire est allouée au début de l'exécution du programme, et elle est réutilisée à chaque appel de la fonction get_next_line. 
- Il n'y a donc pas de risque de dépassement de mémoire, car le tampon reste toujours de taille fixe.
- Dans la plupart des cas, il est utile d'avoir une autre variable pour construire progressivement la ligne entière avant de la retourner, surtout si ta ligne est plus longue que la taille du buffer.
- Cependant cette nouvelle variable sera allouée dynamiquement (avec malloc).

Questions :
- Cette nouvelle variable comment connaître la taille à lui mallocer ?
- Comment déclarer cette nouvelle variable ?

- On ne sait jamais à l'avance la taille exacte de la ligne qui va être lus.
- Il faut donc allouer de la mémoire dynamiquement et, si nécessaire, réallouer plus de mémoire au fur et à mesure que l'on lis des morceaux de la ligne.
- La variable pour stocker la construction de la ligne sera déclaré de la manière suivante :
    => char *line = malloc(128)
- Ensuite en cas de manque d'espace dans cette variable on va agrandir cette mémoir avec realloc :
    => line = realloc(line, nouvelle_taille)
- realloc va permettre d'ajuster la mémoire au fur et à mesure que la ligne se construira.

Questions :
- Où déclarer la taille du buffer ? (BUFFER_SIZE)

- Préférable de déclarer la taille du buffer comme une constante globale.
- Il est donc préférable de déclarer cette constante dans le fichier .h .
- Visibilité : Le fichier d'en-tête est accessible par plusieurs fichiers .c, donc si tu déclares BUFFER_SIZE dans le fichier .h, tous les fichiers qui incluent cet en-tête pourront l'utiliser.
- Facilité de modification : Si tu veux changer la taille du buffer, tu n'auras qu'à modifier BUFFER_SIZE dans un seul endroit (le fichier .h), et cela sera répercuté dans tout ton projet.
- Cohérence : Cela garantit que la taille du buffer reste la même dans tout le projet.

Exemple :
#ifndef GET_NEXT_LINE_H
#define GET_NEXT_LINE_H

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 32  // Tu définis une valeur par défaut si non définie
#endif

char *get_next_line(int fd);

#endif

Problème d'execution du programme :
=> zsh: abort      ./a.out
Le message zsh: abort ./a.out signifie que le programme s'est arrêté brusquement à cause d'une erreur grave. Ce genre d'arrêt est souvent dû à des erreurs de gestion de mémoire ou d'accès à des zones mémoire incorrectes (comme essayer de lire ou écrire là où on ne devrait pas).

Causes possibles et solutions simples
Accès mémoire invalide :
Cela arrive souvent lorsqu'on essaie d'accéder à une adresse mémoire non allouée ou libérée, ou si on dépasse la taille d'une zone mémoire.
Problèmes d'allocation de mémoire :
Si une allocation de mémoire (malloc) échoue et qu'on essaie quand même d'utiliser le pointeur non initialisé, le programme peut planter.


AGAIN : 

Pour l'instant 3 fonctions 

get_next_line() :
    - Vérifie fd et la taille du buffer pour ne pas avoir de d'entrées fausses
    - Vérifie que rien ne se trouve dans la ligne et initialise cette dernière comme étant une chaîne vide (\0)
    - Début de la boucle while
    - Boucle While qui verifie que la fonction ft_condition renvoie bien 0
    - Définition de count avec la fonction read()
    - Condition si count = -1 (il y a une erreur), alors on libère la mémoire allouée à line, line = NULL et return (NULL)
    - Condition si count = 0 et que le pointeur sur le premier caractère de la chaîne line = \0, alors fait la même chose que la condition précédente
    - Condition si count = 0, alors sort de la boucle directement 
    - Si aucune de ces 3 conditions alors continue
    - On met un \0 à la fin du buffer. Comme ça le buffer a toutes les caractéristiques d'une vraie string et peut donc êter lue comme telle
    - On assemble la line et le buffer dans line avec la fonction ft_strjoin() ce qui permet de tout mettre de line à chaque iteration
    - Fin de la boucle while
    - Si line contient un \n ou que le fichier est fini, la boucle s'arrête
    - On envoie ensuite la premiére ligne (avant \n) dans la variable dst avec la fonction ft_jsp

ft_condition() :
    - Regarde dans une string s'il y a un \n
    - S'il y a un \n la fonction return (1)
    - Si non return (0)

read() :
    - ssize_t read(int fd, void *buf, size_t count)
    - fd est le descripteur de fichier à partir duquel lire (souvent obtenu en utilisant la fonction open())
    - buf est un pointeur vers un tampon dans lequel les données lues seront stockées
    - count le nombre maximal d'octets à lire
    - Retourne le nbr d'octets lus
    - Retourne 0 si la fin du fichier (EOF = End Of File) a été atteinte
    - Retourne -1 en cas d'erreur 

ft_strjoin() : 
    - 

ft_put_line() :
    - Regarde dans une string et renvoie un char*
    - Première boucle while agit tant que str[i] n'est pas finie ou que str[i] != \n
    - Dans le cas ou ceci est respecté on regarde le prochain caractère
    - Si ça n'est pas le cas sortie de la boucle
    - On donne i + 1 à la variable size. Et ainsi connaître le nombre de caractèreavant le premier retour à la ligne
    - Condition si str[i] pointe sur \n, alors on augmente size de 1 pour l'ajouter dans le nbr de caractère de la string
    - On malloc la chaine de destination avec la size mais pas de (size + 1) pour le \0 puisque on a déja fait size++ sur la ligne d'avant
    - En toute logique la condition juste avant est censé être juste sinon le malloc fait ensuite n'alloue pas assez de mémoire pour \0
    - Condition si le malloc est faux ou qu'il y a un problème quelconque => return(NULL) (sécurité pour le malloc)
    - Réinitialisation de i à 0 pour réutiliser la variable sans avoir besoin d'en ajouter une nouvelle
    - Deuxième boucle while à les mêmes conditions que la première, cependant elle va servir cette fois-ci à move les caractère de str à dst
    - Condition 

    Questions GPT :
    Est-ce qu'il y a assez de mémoire allouée pour le \0 et un \n ?
    Oui, la taille allouée pour dst est suffisante. L'allocation est calculée comme suit :
    size = i + 1 garantit que la mémoire allouée peut contenir les caractères jusqu'à i + le caractère \0 pour la fin de chaîne.
    Si un \n est présent à la position i, size est augmenté de 1 pour tenir compte de ce \n.Ainsi, il y a toujours suffisamment de mémoire pour contenir la ligne complète avec un \n (le cas échéant) et un \0 à la fin.
    La dernière condition n'est-elle pas forcément vraie si str contient un ou plusieurs \n ?
    Non, ce n'est pas forcément vrai. La condition if (str[i] == '\n') n'est vraie que si un \n est effectivement trouvé à la fin de la ligne que la fonction copie. Si la chaîne ne contient pas de \n à cet endroit (par exemple, si c'est la fin de la chaîne ou si la ligne n'a pas de retour à la ligne), alors la fonction se contente de copier la chaîne sans ajouter de \n.
    En résumé : Cette condition n'est vraie que si un \n a été trouvé dans la chaîne à la position i.
    Pourquoi ajouter un \n dans la ligne retournée ?
    La fonction a pour but de simuler un comportement typique du projet get_next_line : elle renvoie une ligne de texte avec ou sans le caractère \n. Dans le cadre de ce projet, chaque "ligne" inclut potentiellement un \n, donc l'ajouter est une manière de préserver cette information.
    Si un \n est trouvé à la fin de la ligne, il est inclus dans la chaîne retournée.
    Si aucun \n n'est trouvé, la ligne est simplement terminée par un \0, sans ajouter de \n.
    Pourquoi faire ça ? C'est pour permettre à la fonction get_next_line de mieux gérer le texte ligne par ligne, y compris les retours à la ligne. Le caractère \n dans la chaîne retournée est utile pour savoir où la ligne se termine réellement dans le cas où la chaîne contient plusieurs lignes.